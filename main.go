package main

import (
	"fmt"
	"github.com/gofiber/fiber/v2/middleware/pprof"
	db "github.com/khorevaa/odin/database"
	"github.com/khorevaa/odin/models"
	"github.com/khorevaa/odin/utils"
	"github.com/mattn/go-colorable"
	"github.com/mattn/go-isatty"
	"io/ioutil"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"syscall"
	"time"

	"flag"
	swagger "github.com/arsmn/fiber-swagger/v2"
	cli "github.com/jawher/mow.cli"
	"github.com/khorevaa/odin/service"
	"github.com/khorevaa/odin/service/cache"
	"log"

	"github.com/khorevaa/odin/api"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/logger"
	rec "github.com/gofiber/fiber/v2/middleware/recover"
	"github.com/jinzhu/configor"
	_ "github.com/khorevaa/odin/docs" // docs is generated by Swag CLI, you have to import it.

	"github.com/recoilme/pudge"
)

const appName = "odin"

// nolint: gochecknoglobals
var (
	version = "v. dev"
	commit  = "none"
	date    = time.Now().Format(time.RFC3339)
	builtBy = "dev"
)

// main
// @title Odin: Remote Administration for 1S.Enterprise Application Servers
// @version 1.0
// @description ODIN Swagger UI
// @termsOfService http://swagger.io/terms/
// @contact.name API Support
// @contact.email khorevaa@yandex.ru
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host localhost:3001
// @securitydefinitions.oauth2.application OAuth2Application
// @tokenUrl https://example.com/oauth/token
// @scope.write Grants write access
// @scope.read Grants read access
// @scope.metrics Grants read access and control metrics operations
// @scope.admin Grants read and write access to administrative information
// @BasePath /api/v1
func main() {

	var (
		debug                      bool
		prefork                    bool
		port                       string
		appVersion                 string
		preConfigureAppServersFile string
		appData                    string
	)

	app := cli.App(appName, "Remote Administration for 1S.Enterprise Application Servers")

	appVersion = buildVersion()
	app.Version("version v", appVersion)

	app.BoolOptPtr(&debug, "debug", false, "Enable debug")
	app.BoolOptPtr(&prefork, "prefork", false, "Enable prefork in Production")
	app.StringOptPtr(&port, "port p", "localhost:3001", "Port to listen on")
	app.StringOptPtr(&appData, "dir", "", "App data dir")
	app.StringOptPtr(&preConfigureAppServersFile, "config c", "", "File to load preconfigure app servers")

	app.Before = func() {

		if debug {
			// TODO
		}

	}

	app.Action = func() {

		server := fiber.New(fiber.Config{
			Prefork:               prefork,
			DisableStartupMessage: true,
		})

		memoryCache := &cache.Memory{
			Expiration: 30 * time.Minute,
		}

		if len(appData) == 0 {
			appData = utils.GetAppDataDir(appName)
		}

		memoryCache.Connect()

		rep := db.NewRepository(appData)
		serv, err := service.NewService(memoryCache, rep)
		failOnErr(err)

		if len(preConfigureAppServersFile) > 0 {
			loadAppServers(preConfigureAppServersFile, serv)
		}

		// Middleware
		server.Use(rec.New())
		server.Use(service.Middleware(serv))

		if debug {
			server.Use(logger.New())
			server.Use(pprof.New())
		}

		api.Routes(server, serv)

		server.Use("/docs", swagger.Handler) // default

		// Setup static files
		//server.Static("/", "./static/public")

		// Handle not founds
		server.Use(api.NotFound)

		go func() {
			startupMessage(port, false, debug, serv)
			log.Fatal(server.Listen(port)) // go run main.go -port=:3000
		}()

		gracefullyShutdownInit(server)

	}

	app.After = func() {

		_ = pudge.CloseAll()
	}

	app.ErrorHandling = flag.ExitOnError

	err := app.Run(os.Args)
	failOnErr(err)

}

func readLicenseFile(filename string) (string, error) {

	raw, err := ioutil.ReadFile(filename)

	if err != nil {
		return "", err
	}

	return string(raw), nil
}

func loadAppServers(filePath string, serv service.Service) {

	type config struct {
		App []models.AppServer
	}

	var servers config

	err := configor.Load(&servers, filePath)

	if err != nil {
		log.Fatal(err)
	}

	for _, server := range servers.App {
		err := serv.AddAppServer(&server)

		if err != nil {
			log.Printf("error save app server <%s>", err)
			failOnErr(err)
		}
	}

}

func failOnErr(err error) {
	if err != nil {
		println(err.Error())
		cli.Exit(1)
	}
}

func buildVersion() string {
	var result = version
	if commit != "" {
		result = fmt.Sprintf("%s\ncommit: %s", result, commit)
	}
	if date != "" {
		result = fmt.Sprintf("%s\nbuilt at: %s", result, date)
	}
	if builtBy != "" {
		result = fmt.Sprintf("%s\nbuilt by: %s", result, builtBy)
	}

	return result
}

func gracefullyShutdownInit(app *fiber.App) {

	// Wait for interrupt signal to gracefully shutdown the server with
	// setup signal catching
	quit := make(chan os.Signal, 1)
	// catch all signals since not explicitly listing
	signal.Notify(quit, syscall.SIGQUIT, os.Interrupt, os.Kill)

	q := <-quit

	if q != nil {
		println(fmt.Sprintf("RECEIVED SIGNAL: %s", q))
	}
	// Close db
	println("Close db ...")
	if err := pudge.CloseAll(); err != nil {
		log.Println("Database Shutdown err:", err)
	}

	println("Shutdown Server ...")
	if err := app.Shutdown(); err != nil {
		log.Println("Server Shutdown:", err)
	}

	println("Shutdown complete")
	time.Sleep(2 * time.Second)
	cli.Exit(1)

}

func startupMessage(addr string, tls bool, debug bool, serv service.Service) {

	if len(os.Getenv("FIBER_PREFORK_CHILD")) > 0 {
		// Для пожчиненных процессов мы не выводим сообщение
		return
	}

	var logo string
	logo += "%s"
	logo += " ┌───────────────────────────────────────────────────┐\n"
	logo += " │ %s │\n"
	logo += " │ %s │\n"
	logo += " │ %s │\n"
	logo += " │ %s │\n"
	logo += " │ %s │\n"
	logo += " │ %s │\n"
	logo += " │                                                   │\n"
	logo += " │ Built by: %s Built at: %s │\n"
	logo += " │ Cache: %s DB: %s │\n"
	logo += " └───────────────────────────────────────────────────┘"
	logo += "%s"

	const (
		cBlack = "\u001b[90m"
		// cRed   = "\u001b[91m"
		cCyan = "\u001b[96m"
		// cGreen = "\u001b[92m"
		cYellow = "\u001b[93m"
		// cBlue    = "\u001b[94m"
		// cMagenta = "\u001b[95m"
		// cWhite   = "\u001b[97m"
		cReset = "\u001b[0m"
	)

	value := func(s string, width int) string {
		pad := width - len(s)
		str := ""
		for i := 0; i < pad; i++ {
			str += "."
		}
		if s == "Disabled" {
			str += " " + s
		} else {
			str += fmt.Sprintf(" %s%s%s", cYellow, s, cBlack)
		}
		return str
	}

	center := func(s string, width int) string {
		pad := strconv.Itoa((width - len(s)) / 2)
		str := fmt.Sprintf("%"+pad+"s", " ")
		str += s
		str += fmt.Sprintf("%"+pad+"s", " ")
		if len(str) < width {
			str += " "
		}
		return str
	}

	centerValue := func(s string, width int) string {
		pad := strconv.Itoa((width - len(s)) / 2)
		str := fmt.Sprintf("%"+pad+"s", " ")
		str += fmt.Sprintf("%s%s%s", cCyan, s, cBlack)
		str += fmt.Sprintf("%"+pad+"s", " ")
		if len(str)-10 < width {
			str += " "
		}
		return str
	}

	host, port := parseAddr(addr)
	if host == "" || host == "0.0.0.0" {
		host = "127.0.0.1"
	}
	addr = "http://" + host + ":" + port
	if tls {
		addr = "https://" + host + ":" + port
	}

	t, _ := time.Parse(time.RFC3339, date)

	cacheInfo := "redis"
	switch serv.GetCache().(type) {
	case *cache.Memory:
		cacheInfo = "in memory"
	}

	dbInfo := "pudge"
	pprofInfo := ""
	if debug {
		pprofInfo = " Pprof: " + addr + "/debug/pprof"
	}

	switch serv.Repository().(type) {
	case *db.InMemory:
		dbInfo = "in memory"
	}

	mainLogo := fmt.Sprintf(logo,
		cBlack,
		centerValue(" ODIN "+version, 49),
		center("Remote Administration", 49),
		center("for 1S.Enterprise Application Servers", 49),
		centerValue(" API: "+addr+"/api/v1", 49),
		centerValue(" Docs: "+addr+"/docs", 49),
		centerValue(pprofInfo, 49),
		value(builtBy, 13), value(t.Format("2006-01-02"), 13),
		value(cacheInfo, 16), value(dbInfo, 19),
		cReset,
	)

	out := colorable.NewColorableStdout()
	if os.Getenv("TERM") == "dumb" ||
		(!isatty.IsTerminal(os.Stdout.Fd()) &&
			!isatty.IsCygwinTerminal(os.Stdout.Fd())) {
		out = colorable.NewNonColorable(os.Stdout)
	}

	fmt.Fprintln(out, mainLogo)

}

func parseAddr(raw string) (host, port string) {
	if i := strings.LastIndex(raw, ":"); i != -1 {
		return raw[:i], raw[i+1:]
	}
	return raw, ""
}
